---
description: Generate single-environment GitHub Actions workflows with CI/CD, dependency handling, and artifact flow.
alwaysApply: false
---

# CICD Workflow Generation Phase 2: Generate Workflow Files

## Purpose

Generate GitHub Actions workflow files (YAML) for ALL detected code types as **one workflow file per code type**. Each workflow contains CI jobs and deployment job. Handle dependencies between code artifacts by enforcing workflow execution order and artifact passing. Ensure all required CI/CD and code scanning steps are present.

## Plan Document Location

Plan documents are created in `.cicd-docs/` directory:

- Workflow generation plan: `.cicd-docs/workflow-generation-plan.md`

## MANDATORY: GitHub Actions Expression Syntax

**CRITICAL**: When using GitHub Actions functions like `hashFiles`, `always()`, `success()`, etc., they MUST always be wrapped in `${{ }}` expression syntax.

- **Correct**: `if: ${{ hashFiles('tests/**') != '' }}`
- **Incorrect**: `if: hashFiles('tests/**') != ''` (will cause "Unrecognized function" error)

**All GitHub Actions expressions must use `${{ }}` syntax**, including:

- `hashFiles()` - Check if files exist or have changed
- `always()`, `success()`, `failure()`, `cancelled()` - Job status checks
- `github.event.*` - Event context access

**CRITICAL - `hashFiles()` Context Limitation**: The `hashFiles()` function is **ONLY available in step-level `if` conditions** (`jobs.<job>.steps[*].if`), **NOT at the job level** (`jobs.<job>.if`).

If you need to conditionally run an entire job based on file existence, either:

1. Always run the job but skip steps conditionally using step-level `if` conditions
2. Use a separate job to check file existence and set an output, then reference that output in the job's `if` condition

## MANDATORY: Workflow Linting and Validation

**CRITICAL**: All generated CICD workflow files MUST be free of linting errors. Before finalizing any workflow:

1. **Validate YAML syntax**: Ensure all YAML is valid and properly formatted
2. **Validate GitHub Actions syntax**: Verify all expressions use correct `${{ }}` syntax
3. **Check for common errors**:
   - Missing required fields (name, on, jobs, runs-on, etc.)
   - Invalid job dependencies (circular dependencies, missing job references)
   - Incorrect workflow trigger syntax
   - Missing or incorrect environment names
   - Invalid artifact names or paths
   - Incorrect condition syntax
4. **Test workflow structure**: Verify workflow structure is valid GitHub Actions YAML
5. **Fix any linting errors immediately** - DO NOT proceed to Phase 3 if workflows have linting errors

## Steps

1. **Load Dependency Information from Phase 1:**

   - **Read Dependency Map**:

     - Load dependency relationships from Phase 1 plan document
     - Load dependency map from `.cicd-docs/cicd-state.md` if available
     - Understand which code types depend on others (e.g., `terraform → depends on → python`)

   - **Identify Artifact Requirements**:
     - For each dependency, identify what artifacts need to be passed
     - Example: Terraform needs Python Lambda zip file location
     - Document artifact types: zip files, Docker images, build artifacts, etc.

2. **Verify Clean State:**

   - **For regeneration requests**: `.github/workflows/` directory should already be deleted (handled in Welcome phase), so no existing workflows to manage
   - **For new generation**: If `.github/workflows/` directory exists with files, they will be replaced with newly generated workflows
   - **No complex removal logic needed**: Simply generate new workflow files - they will overwrite any existing files with the same names
   - Document that new workflows are being generated (1 per code type)

3. **Read Language-Specific Standards:**

   - For each detected code type, read the corresponding standards file:
     - `.cursor/rules/cicd-phases/{code-type}-standards.mdc`
   - If standards file does not exist, create it following the pattern of existing standards files
   - **CRITICAL**: Use the complete content from the standards file - do not summarize or paraphrase

4. **Generate Workflows Per Detected Code Type:**

   For each detected code type, generate **one workflow file**:

   **Workflow** (`.github/workflows/{code-type}.yml`):

   - **Workflow Trigger**:

     - Trigger on push to `main` branch AND support `workflow_run` if dependencies exist

     ```yaml
     on:
       push:
         branches: [main]
       workflow_dispatch:
       workflow_run:
         workflows: ["{Upstream Workflow Name}"]
         types: [completed]
         branches: [main]
     ```

     - **If dependencies exist**: Add `workflow_run` trigger to wait for upstream workflows
     - **Condition Check** (for workflow_run):
       ```yaml
       jobs:
         deploy:
           if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'push' }}
       ```

   - **CI Jobs**:

     - Lint, test, security scan, artifact generation
     - Organize workflow logic into multiple jobs with clear dependencies using `needs:`
     - Prefer fast-fail by running independent jobs in parallel
     - Build and upload artifacts
     - Follow patterns from `{code-type}-standards.mdc`

   - **Deploy Job**:
     - **Needs**: All CI jobs must succeed
     - **Dependency Handling** (CRITICAL - MANDATORY if dependencies detected):
       - **MANDATORY CHECK**: If Phase 1 detected dependencies for this code type, dependency handling steps MUST be included
       - **Load Artifact Mapping** (PREFERRED):
         - **CRITICAL**: Read `.code-docs/artifact-mappings.json` if it exists
         - Extract dependency information from `mappings` array
         - For each mapping entry:
           - Use `artifact_name` for artifact download
           - Use `artifact_destination_path` for artifact placement
       - **For Terraform workflows**: If Terraform code references artifacts OR mapping file indicates dependencies, dependency handling is MANDATORY
       - **Steps MUST include** (in this exact order):
         1. **Download artifacts from upstream workflows FIRST** (e.g., Lambda zip from Python workflow)
            - **If mapping file exists**: Use exact artifact name from mapping
            - **If mapping file does not exist**: Use patterns from `terraform-standards.mdc` or `workflow-dependency-handling.mdc`
         2. **Place artifacts in correct location** where deployment code expects them
            - **If mapping file exists**: Use exact path from `artifact_destination_path` field
            - **If mapping file does not exist**: For Terraform, if code references `lambda_function.zip`, place it where Terraform expects it
         3. **Verify artifacts exist** before proceeding with deployment operations
         4. **Pass artifact information** to deployment steps (environment variables, Terraform variables, etc.)
       - **DO NOT SKIP**: If dependencies are detected, these steps are MANDATORY, not optional
     - Deploys to environment
     - Uses GitHub `environment` for secrets and protection rules
     - Downloads CI artifacts if needed for deployment
     - **Upload deployment artifacts** for downstream workflows (if this code type is a dependency)
     - Follow patterns from `{code-type}-standards.mdc`

5. **Workflow Structure Requirements:**

   **CRITICAL**: Remember that all GitHub Actions expressions (including `hashFiles`) MUST be wrapped in `${{ }}` syntax.

   - **Workflow Structure Example**:

     ```yaml
     name: { Code Type }

     on:
       push:
         branches: [main]
       workflow_dispatch:
       workflow_run:
         workflows: ["{Upstream Workflow Name}"]
         types: [completed]
         branches: [main]

     permissions:
       contents: read
       id-token: write # For OIDC if needed

     jobs:
       # CI Jobs
       lint:
         runs-on: ubuntu-latest
         steps:
           - uses: actions/checkout@v4
           # ... lint steps from standards file

       security:
         runs-on: ubuntu-latest
         steps:
           - uses: actions/checkout@v4
           # ... security scan steps from standards file

       tests:
         runs-on: ubuntu-latest
         steps:
           - uses: actions/checkout@v4
           - name: Run tests
             if: ${{ hashFiles('tests/**') != '' }}
             run: |
               # ... test steps from standards file

       # Deployment Job
       deploy:
         if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'push' }}
         needs: [lint, security, tests]
         runs-on: ubuntu-latest
         environment: default # Or custom environment name
         steps:
           - uses: actions/checkout@v4
             with:
               ref: ${{ github.event.workflow_run.head_branch || github.ref }}
           # ... deployment steps from standards file
     ```

   - **AWS Credentials Configuration** (Mandatory for AWS-related workflows):
     If any workflow step requires AWS CLI credentials, include OIDC configuration:

     ```yaml
     - name: Configure AWS credentials via OIDC
       uses: aws-actions/configure-aws-credentials@v4
       with:
         role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
         aws-region: ${{ vars.AWS_REGION }}
     ```

     - Place this step as one of the first steps in any job that performs AWS operations
     - Require `permissions: id-token: write` at the workflow level

   - **Path Filters**:
     If a workflow uses `paths` filters, always include the workflow file itself:

     ```yaml
     on:
       push:
         branches: [main]
         paths:
           - "src/**"
           - ".github/workflows/{code-type}.yml"
     ```

   - **Concurrency Control**:
     Use concurrency groups to avoid overlapping deployments:

     ```yaml
     concurrency:
       group: deploy-{code-type}-${{ github.ref }}
       cancel-in-progress: false
     ```

6. **Apply Language-Specific Standards:**

   - For each detected code type, read and apply the complete content from `{code-type}-standards.mdc`
   - Use the exact job names, steps, and patterns specified in the standards file
   - Do not modify or summarize the standards - use them as written
   - **CRITICAL - For Terraform Workflows**:
     - **MANDATORY Dependency Check**: Before generating deployment job, check if Terraform has dependencies
     - If dependencies exist, deployment job MUST include dependency handling steps from `terraform-standards.mdc`
   - If a standards file is missing, create it with appropriate CI/CD patterns for that code type

7. **Document Dependency Handling:**

   - For each dependency relationship identified in Phase 1:
     - Document which upstream workflow must complete first
     - Document which downstream workflow waits for it
     - Document what artifacts are passed between workflows
     - Document how artifacts are passed (GitHub Actions artifacts)

8. **Validate Workflow Linting and Dependency Handling (MANDATORY):**

   - **CRITICAL**: Before presenting preview, validate all generated workflow files for linting errors:
     - Check YAML syntax validity
     - Verify all GitHub Actions expressions use `${{ }}` syntax (especially `hashFiles`)
     - Verify no missing required fields (name, on, jobs, runs-on, etc.)
     - Check for valid job dependencies (no circular dependencies, all referenced jobs exist)
     - Verify workflow trigger syntax is correct
     - Check environment names are valid
     - Verify artifact paths and names are correct
   - **CRITICAL - Dependency Handling Validation** (MANDATORY for Terraform workflows):
     - **For each Terraform workflow generated**:
       - Check if Terraform code references artifacts (scan `.tf` files for `filename = "*.zip"`, etc.)
       - Check Phase 1 dependency map for Terraform dependencies
       - **If dependencies detected**: Verify deployment job includes ALL mandatory dependency handling steps
       - **If dependencies detected but steps missing**: Add missing steps immediately - DO NOT proceed without them
   - **If linting errors are found**: Fix them immediately before proceeding
   - **If dependency handling steps are missing**: Add them immediately before proceeding
   - **DO NOT proceed to preview if workflows have linting errors OR missing dependency handling steps**

9. **Present Workflow YAML Preview:**

   - Show summarized YAML contents for all generated workflow files:
     - `{code-type}.yml` for each detected code type
   - Include key jobs (CI jobs + deployment job), triggers, environments, permissions, and artifact passing
   - **Highlight dependency handling**:
     - Show artifact download/upload steps
     - Show how artifacts are passed to deployment steps
   - List any workflows that were modified or removed
   - **Show dependency graph**: Visual representation of which workflows depend on others
   - **Show execution order**: Show the execution order determined by dependencies
   - **Confirm linting validation**: State that all workflows have been validated and are free of linting errors

10. **Checkpoint:**
    - Prompt user to confirm: "Proceed to generate CI/CD workflows for all detected code types?"
    - Wait for confirmation.
    - **Update plan checkboxes** - Mark completed steps [x] in `.cicd-docs/workflow-generation-plan.md`
    - **Update cicd-state.md** - Update Phase 2 status and generated files list
