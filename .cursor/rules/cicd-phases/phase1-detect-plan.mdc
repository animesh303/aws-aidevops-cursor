---
description: Scan and analyze code, dependencies, and workflows to design a single-environment CI/CD plan.
alwaysApply: false
---

# CICD Workflow Generation Phase 1: Detect & Plan

## Purpose

Scan repository for ALL code types (Python, Terraform, JavaScript, Java, Go, Docker, Kubernetes, etc.), load and analyze requirements files to understand dependencies, analyze existing workflows, and create a plan for single-environment CI/CD workflows.

## Plan Document Location

Plan documents are created in `.cicd-docs/` directory:
- Detection plan: `.cicd-docs/detection-plan.md`
- Workflow generation plan: `.cicd-docs/workflow-generation-plan.md`
- Review notes: `.cicd-docs/review-notes.md`

## Steps

1. **Load Requirements Files for Dependency Analysis:**

   - **Scan for Requirements Files**:
     - Check `.code-docs/requirements/` directory
     - Check `.requirements/` directory (alternative location)
     - Load all `*_requirements.md`, `*-analysis.md`, and `*-code-analysis.md` files

   - **Extract Dependency Information**:
     - Read requirements files to understand relationships between code artifacts
     - Identify dependencies: e.g., "Terraform infrastructure depends on Python Lambda deployment package"
     - Map dependencies using structured format: `{code-type: "terraform", depends_on: "python", artifacts: ["lambda-package.zip"]}`
     - For human-readable summaries, use arrow notation: `terraform → depends on → python`

   - **Document Dependencies**:
     - Create dependency map in the plan document
     - Store in cicd-state.md as array: `[{code-type: "terraform", depends_on: "python", artifacts: ["lambda-package.zip"]}, ...]`
     - Identify which workflows must wait for others to complete
     - Note artifact requirements

2. **Scan Project Root and Subdirectories for Code Types:**

   - **Python**: Detect `.py` files, `requirements.txt`, `setup.py`, `pyproject.toml`, `Pipfile`
   - **Terraform**: Detect `.tf`, `.tfvars` files, `terraform/` directories
   - **JavaScript/TypeScript**: Detect `.js`, `.jsx`, `.ts`, `.tsx` files, `package.json`, `node_modules/`
   - **Java**: Detect `.java` files, `pom.xml`, `build.gradle`, Maven/Gradle directories
   - **Go**: Detect `.go` files, `go.mod`, `go.sum`
   - **Docker**: Detect `Dockerfile`, `docker-compose.yml`, `.dockerignore`
   - **Kubernetes**: Detect `.yaml`/`.yml` files in `k8s/`, `kubernetes/`, `manifests/` directories
   - **CloudFormation**: Detect `.yaml`/`.yml` files with CloudFormation templates, `cfn/` directories
   - **CDK**: Detect `cdk.json`, `cdk/` directories, CDK code files
   - List specific subpaths for each detected code type

3. **Analyze Existing Workflows:**

   - Scan `.github/workflows/` directory for existing workflow files (if directory exists)
   - **If `.github/workflows/` directory exists and contains files**:
     - Document existing workflow patterns for reference
     - Note: These workflows will be replaced with newly generated workflows
   - **If `.github/workflows/` directory doesn't exist or is empty**: No existing workflows to analyze

4. **Identify Detected Code Types:**

   - Create a summary of all detected code types with their locations
   - Example: "Python detected in `src/`; Terraform detected in `iac/terraform/`"
   - Cross-reference with Requirements: Verify detected code types match requirements analysis
   - Validate Dependencies: Ensure dependency relationships from requirements are valid

5. **Analyze Code Dependencies:**

   - **Load Artifact Mapping** (PREFERRED METHOD):
     - **CRITICAL**: First check if `.code-docs/artifact-mappings.json` exists
     - If mapping file exists:
       - Read and parse the JSON file
       - Extract dependency information from `mappings` array
       - Use `lambda_functions` array to identify all Lambda functions
       - Use `terraform_resources` array to identify all Terraform resources that need artifacts
     - If mapping file does not exist, fall back to code analysis (below)

   - **Build Dependency Map**:
     - For each code type, identify what it depends on (from requirements analysis AND code analysis)
     - **Code Analysis for Dependencies** (FALLBACK if mapping file not available):
       - **Terraform Code Analysis**: Scan all `.tf` files for artifact references:
         - Search for `filename = "lambda_function.zip"` or similar patterns
         - Search for `source = "*.zip"` or `archive_path = "*.zip"`
         - If Terraform references `.zip` files, Lambda packages, or other artifacts, mark as dependency
       - **Docker Code Analysis**: Scan Dockerfiles for `COPY` or `ADD` commands referencing code artifacts
       - **Kubernetes Code Analysis**: Scan manifests for image references that need to be built
       - **General Pattern**: If code type A references artifacts that code type B produces, A depends on B
     - **When Using Mapping File**: Extract dependency information directly from mapping
     - Document build order: e.g., "Python Lambda must be built before Terraform deployment"
     - Identify artifact requirements: what artifacts need to be produced and consumed

   - **Workflow Dependency Requirements**:
     - Determine which workflows must wait for others using `workflow_run` triggers
     - Identify which artifacts need to be uploaded/downloaded between workflows
     - **When Using Mapping File**: Use exact artifact names from mapping
     - Document artifact passing requirements (e.g., Lambda zip file path, Docker image tag)
     - **MANDATORY**: If dependencies are detected, they MUST be implemented in workflows

6. **Draft Single-Environment Workflow Plan:**

   For each detected code type, plan **one workflow file**:
   - **Workflow** (`{code-type}.yml`):
     - Triggers on pushes to `main` branch (and `workflow_dispatch` for manual trigger)
     - Contains CI jobs (lint, test, security scan, artifact generation) + Deploy job
     - Uses GitHub `environment` for secrets

   **Document Dependency Handling:**
   - For each dependency relationship, specify:
     - Which workflow must complete first (upstream)
     - Which workflow depends on it (downstream)
     - What artifacts need to be passed (e.g., Lambda zip file, Docker image tag)
     - How artifacts will be passed (GitHub Actions artifacts)
     - Example: "Terraform workflow must wait for Python workflow to complete and upload Lambda zip artifact"

   Document workflow modifications:
   - List existing workflows that need modification
   - List existing workflows that should be removed
   - List new workflows that need to be created (1 per code type)
   - Document dependency-based workflow triggers and artifact passing

7. **User Plan Review Checkpoint:**

   - Present summary of:
     - All detected code types with locations
     - Requirements and dependencies identified
     - Dependency map (which code types depend on others)
     - Workflow dependency order (which workflows must run before others)
     - Existing workflows analysis (keep/modify/remove)
     - Planned workflows (1 per code type)
     - Artifact passing strategy (how dependencies will be handled between workflows)
   - Ask: "Proceed to generate workflow files as planned?"
   - Wait for confirmation to proceed.

8. **Persist Phase Results (State & Audit):**

   - Write detected code types, dependency map, existing workflow analysis, and the draft plan to `.cicd-docs/cicd-state.md`
   - Include dependency relationships and artifact requirements in the state file
   - Record the user confirmation decision with timestamp in `.cicd-docs/audit.md`
   - **Update plan checkboxes** - Mark completed steps [x] in `.cicd-docs/detection-plan.md`
   - **Update cicd-state.md** - Update Phase 1 status after completion
