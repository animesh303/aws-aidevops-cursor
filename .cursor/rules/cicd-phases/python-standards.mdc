---
description: Define CI/CD workflow patterns and standards for Python code in single production workflow.
alwaysApply: false
---

# Python CI/CD Workflow Standards

## Purpose

Define CI/CD workflow patterns and standards for Python code in single production workflow (triggered by main branch).

## CI Jobs

### Lint Job

- **Name**: `python-lint`
- **Matrix**: Python versions (3.10, 3.11, 3.12)
- **Continue on Error**: `continue-on-error: true` (job level) - allows workflow to continue even if linting fails
- **Steps**:
  - Setup Python with matrix version
  - Cache pip dependencies
  - Install dependencies: `pip install -r requirements.txt`
  - Run Flake8:
    ```yaml
    - name: Run Flake8
      run: |
        pip install flake8
        flake8 . || true  # Continue even if flake8 finds issues
    ```

### Security Job

- **Name**: `python-security`
- **Matrix**: Optional Python versions
- **Continue on Error**: `continue-on-error: true` (job level) - allows workflow to continue even if security scan finds issues
- **Steps**:
  - Setup Python
  - Cache pip dependencies
  - Install dependencies
  - Run Bandit:
    ```yaml
    - name: Run Bandit
      run: |
        pip install bandit
        bandit -r . || true  # Continue even if bandit finds security issues
    ```

### Tests Job

- **Name**: `python-tests`
- **Condition**: Only run if `tests/` directory exists
- **Matrix**: Python versions (3.10, 3.11, 3.12)
- **Continue on Error**: `continue-on-error: true` (job level) - allows workflow to continue even if tests fail
- **Steps**:
  - Setup Python with matrix version
  - Cache pip dependencies
  - Install dependencies including test requirements
  - Run pytest with coverage:
    ```yaml
    - name: Run tests
      run: |
        pytest tests/ --cov=. --cov-report=xml --cov-report=html || true  # Continue even if tests fail
    ```
  - Upload coverage artifacts (coverage.xml, htmlcov/) - use `if: always()` to upload even if tests fail

## Build Job

- **Name**: `python-build`
- **Needs**: All CI jobs (`python-lint`, `python-security`, `python-test`)
- **Steps**:
  - Setup Python
  - Cache pip dependencies
  - Install dependencies
  - **Build Lambda deployment package** (if applicable):
    ```yaml
    - name: Build Lambda package
      run: |
        zip -r lambda-package.zip . -x "*.git*" "*.md" "tests/*"
    ```
  - **Upload artifacts for downstream jobs** (if this Python code is a dependency):
    ```yaml
    - name: Upload Lambda package artifact
      uses: actions/upload-artifact@v4
      with:
        name: lambda-package
        path: lambda-package.zip
        retention-days: 1
    ```

## Deployment Job

- **Name**: `python-deploy`
- **Needs**: Build job (`python-build`) and all CI jobs
- **Condition**: `if: always()` - runs even if CI jobs fail (since CI jobs use `continue-on-error: true`)
- **Environment**: `production`
- **Workflow Trigger**: `push` to `main` branch only
- **Steps**:
  - Checkout code
  - Configure AWS credentials via OIDC (if needed)
  - Download build artifacts if needed (from build job)
  - Deploy to production environment
  - Use production environment secrets and variables
  - Protected with GitHub environment protection rules

## Permissions

- **AWS Operations**: `id-token: write` (for OIDC)
- **Contents**: `read` (default)

## Common Patterns

- Cache pip dependencies for faster builds
- Use matrix strategy for multiple Python versions
- Conditional test execution based on `tests/` directory existence
- Artifact upload in build job, download in deploy job (within same workflow)
- Production environment configuration via GitHub environments
- **Non-blocking CI jobs**: All CI jobs (lint, security, tests) use `continue-on-error: true` to allow workflow to proceed even if CI checks fail
- **Deployment always runs**: Deployment job uses `if: always()` condition to ensure it runs regardless of CI job outcomes

## Dependency Handling

**When Python code is a dependency for other code types** (e.g., Terraform needs Lambda package):

- **Build and Package**: Create Lambda deployment package (zip file) in build job
- **Upload Artifacts**: Upload packages using `actions/upload-artifact@v4` in build job
- **Artifact Naming**: Use simple, consistent naming: `lambda-package` (no environment suffix needed for single workflow)
- **Download in Downstream Jobs**: Downstream deploy jobs (e.g., `terraform-deploy`) download artifacts from build job using `actions/download-artifact@v4`
- **Artifact Passing**: All artifact passing happens within the same workflow using GitHub Actions artifacts
